Here is the comprehensive physical data model for the Gold layer, designed for Google BigQuery.

### **Assumptions and Design Decisions**

1.  **Surrogate Keys:** Surrogate keys (e.g., `applicant_sk`, `card_product_sk`) have been added to each dimension table. These are `INT64` fields, typically generated by a hash function (e.g., `FARM_FINGERPRINT`) on the natural key(s) from the Silver layer during the ETL process. These keys are used to join fact tables to dimensions, which is a best practice for historical tracking and performance.
2.  **Denormalization:** The Gold layer is intentionally denormalized into a star schema. The `Go_Fact_Application` and `Go_Fact_Transaction` tables centralize metrics and connect to multiple dimension tables that store descriptive attributes. This design simplifies queries for BI and analytics tools.
3.  **SCD Type 2 Implementation:** For `Go_Dim_Applicant` (SCD Type 2), `start_date`, `end_date`, and `is_current` columns are included to track historical changes in applicant attributes. A unique surrogate key (`applicant_sk`) is assigned to each version of an applicant's record.
4.  **Partitioning and Clustering:** Tables are partitioned by a primary `DATE` column (e.g., `application_date` for facts, `load_date` for dimensions) to enable time-based query pruning, reducing costs and improving performance. Clustering is applied on foreign keys (surrogate keys) and commonly filtered columns to further optimize joins and filtering operations.
5.  **ID Fields:** All ID fields from the Silver layer (e.g., `applicant_id`, `application_id`) are retained in the corresponding Gold dimension tables as natural keys or for lineage tracking. They are used to look up surrogate keys during the ETL process.
6.  **Constraints:** In adherence to BigQuery best practices, no physical `PRIMARY KEY` or `FOREIGN KEY` constraints are defined in the DDLs. These relationships are logical and are documented in the conceptual model diagram.

---

### **1. Gold Layer**

#### **DDL scripts (Fact and Dimension tables)**

```sql
-- DDL for Go_Dim_Applicant (SCD Type 2)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Applicant (
    applicant_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the applicant dimension record."),
    applicant_id INT64 NOT NULL OPTIONS(description="Natural key from the source system (si_applicants)."),
    geography STRING OPTIONS(description="The geographical region or state where the applicant resides."),
    age_group STRING OPTIONS(description="The derived age bracket of the applicant (e.g., '25-34', '35-44')."),
    income_level STRING OPTIONS(description="The derived income bracket of the applicant (e.g., '50k-75k')."),
    employment_type STRING OPTIONS(description="The standardized employment status of the applicant (e.g., 'Full-time')."),
    start_date DATE NOT NULL OPTIONS(description="The date from which this version of the applicant record is effective."),
    end_date DATE OPTIONS(description="The date until which this version of the applicant record was effective. NULL for current records."),
    is_current BOOLEAN NOT NULL OPTIONS(description="A flag (True/False) indicating if this is the current version of the record."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
PARTITION BY
  DATE(load_date)
CLUSTER BY
  applicant_id, geography, is_current
OPTIONS (
  description = "SCD Type 2 Dimension table storing descriptive attributes of credit card applicants over time.",
  labels = [('layer', 'gold'), ('domain', 'applicant')]
);

-- DDL for Go_Dim_Card_Product (SCD Type 1)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Card_Product (
    card_product_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the card product dimension."),
    card_product_id INT64 NOT NULL OPTIONS(description="Natural key from the source system (si_card_products)."),
    product_name STRING OPTIONS(description="The standardized name of the credit card product."),
    category STRING OPTIONS(description="Standardized category of the card (e.g., 'Rewards', 'Travel')."),
    interest_rate FLOAT64 OPTIONS(description="The standardized interest rate for the product."),
    annual_fee FLOAT64 OPTIONS(description="The standardized annual fee for the product."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
CLUSTER BY
  card_product_id, category
OPTIONS (
  description = "SCD Type 1 Dimension table for credit card products offered.",
  labels = [('layer', 'gold'), ('domain', 'product')]
);

-- DDL for Go_Dim_Acquisition_Channel (SCD Type 1)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Acquisition_Channel (
    acquisition_channel_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the acquisition channel dimension."),
    channel_name STRING OPTIONS(description="The standardized name of the acquisition channel (e.g., 'Online', 'In-Branch')."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
CLUSTER BY
  channel_name
OPTIONS (
  description = "SCD Type 1 Dimension table for various acquisition channels.",
  labels = [('layer', 'gold'), ('domain', 'marketing')]
);

-- DDL for Go_Dim_Campaign (SCD Type 1)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Campaign (
    campaign_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the campaign dimension."),
    campaign_id INT64 NOT NULL OPTIONS(description="Natural key from the source system (si_campaigns)."),
    campaign_name STRING OPTIONS(description="The standardized name of the marketing campaign."),
    campaign_type STRING OPTIONS(description="The standardized type of the campaign (e.g., 'Digital', 'Direct Mail')."),
    start_date DATE OPTIONS(description="The official start date of the campaign."),
    end_date DATE OPTIONS(description="The official end date of the campaign."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
CLUSTER BY
  campaign_id, campaign_type
OPTIONS (
  description = "SCD Type 1 Dimension table for marketing campaigns.",
  labels = [('layer', 'gold'), ('domain', 'marketing')]
);

-- DDL for Go_Dim_Credit_Risk (SCD Type 1)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Credit_Risk (
    credit_risk_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the credit risk dimension."),
    credit_score_id INT64 NOT NULL OPTIONS(description="Natural key from the source system (si_credit_scores)."),
    credit_score INT64 OPTIONS(description="The credit score of the applicant."),
    risk_tier STRING OPTIONS(description="The risk category assigned based on the credit score (e.g., 'Low Risk')."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
CLUSTER BY
  credit_score_id, risk_tier
OPTIONS (
  description = "SCD Type 1 Dimension table for the credit risk profile of an applicant.",
  labels = [('layer', 'gold'), ('domain', 'risk')]
);

-- DDL for Go_Dim_Fraud_Check (SCD Type 1)
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Fraud_Check (
    fraud_check_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the fraud check dimension."),
    fraud_check_id INT64 NOT NULL OPTIONS(description="Natural key from the source system (si_fraud_checks)."),
    fraud_check_type STRING OPTIONS(description="The standardized type of fraud check performed (e.g., 'Identity Verification')."),
    screening_result STRING OPTIONS(description="The standardized result of the specific fraud screening check."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    update_date TIMESTAMP OPTIONS(description="The date the record was last updated."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
CLUSTER BY
  fraud_check_id, fraud_check_type
OPTIONS (
  description = "SCD Type 1 Dimension table for the fraud screening process.",
  labels = [('layer', 'gold'), ('domain', 'fraud')]
);

-- DDL for Go_Dim_Date
CREATE TABLE IF NOT EXISTS Gold.Go_Dim_Date (
    date_sk INT64 NOT NULL OPTIONS(description="Surrogate key for the date dimension (e.g., YYYYMMDD)."),
    date DATE NOT NULL OPTIONS(description="A full date value."),
    year INT64 OPTIONS(description="The year of the date."),
    quarter INT64 OPTIONS(description="The quarter of the year (1-4)."),
    month INT64 OPTIONS(description="The month of the year (1-12)."),
    day_of_week STRING OPTIONS(description="The day of the week (e.g., 'Monday')."),
    week_of_year INT64 OPTIONS(description="The week number of the year.")
)
CLUSTER BY
  year, quarter, month
OPTIONS (
  description = "Standard date dimension to facilitate time-based analysis.",
  labels = [('layer', 'gold'), ('domain', 'shared')]
);

-- DDL for Go_Fact_Application
CREATE TABLE IF NOT EXISTS Gold.Go_Fact_Application (
    application_id INT64 NOT NULL OPTIONS(description="Unique identifier for the application (natural key)."),
    applicant_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Applicant table."),
    card_product_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Card_Product table."),
    acquisition_channel_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Acquisition_Channel table."),
    campaign_sk INT64 OPTIONS(description="Foreign key to the Go_Dim_Campaign table."),
    credit_risk_sk INT64 OPTIONS(description="Foreign key to the Go_Dim_Credit_Risk table."),
    fraud_check_sk INT64 OPTIONS(description="Foreign key to the Go_Dim_Fraud_Check table."),
    application_date_sk INT64 NOT NULL OPTIONS(description="Foreign key to Go_Dim_Date for application submission date."),
    approval_date_sk INT64 OPTIONS(description="Foreign key to Go_Dim_Date for application approval date."),
    activation_date_sk INT64 OPTIONS(description="Foreign key to Go_Dim_Date for card activation date."),
    application_outcome STRING OPTIONS(description="The final status of the application (e.g., 'Approved', 'Rejected')."),
    fraud_screening_result STRING OPTIONS(description="The outcome of the fraud screening process (e.g., 'Pass', 'Fail')."),
    time_to_approval_days INT64 OPTIONS(description="The number of days from application to approval."),
    time_to_activation_days INT64 OPTIONS(description="The number of days from approval to activation."),
    application_count INT64 DEFAULT 1 OPTIONS(description="A constant value of 1 for easy counting of applications."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
PARTITION BY
  DATE_TRUNC(DATE(TIMESTAMP_SECONDS(CAST(application_date_sk / 1000 AS INT64))), MONTH)
CLUSTER BY
  applicant_sk, card_product_sk, application_outcome
OPTIONS (
  partition_expiration_days = 3650, -- ~10 years
  description = "Central fact table capturing credit card application lifecycle events and metrics.",
  labels = [('layer', 'gold'), ('domain', 'application')]
);

-- DDL for Go_Fact_Transaction
CREATE TABLE IF NOT EXISTS Gold.Go_Fact_Transaction (
    transaction_id INT64 NOT NULL OPTIONS(description="Unique identifier for the transaction (natural key, e.g., activation_id)."),
    applicant_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Applicant table."),
    card_product_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Card_Product table."),
    transaction_date_sk INT64 NOT NULL OPTIONS(description="Foreign key to Go_Dim_Date for the first transaction date."),
    transaction_amount FLOAT64 OPTIONS(description="The monetary amount of the first transaction."),
    time_to_first_transaction_days INT64 OPTIONS(description="The number of days from card activation to the first transaction."),
    promotional_offer_detail STRING OPTIONS(description="Details of any promotional offer associated with the transaction."),
    transaction_count INT64 DEFAULT 1 OPTIONS(description="A constant value of 1 for easy counting of transactions."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the record was loaded into the Gold layer."),
    source_system STRING OPTIONS(description="The source system from which this data originated.")
)
PARTITION BY
  DATE_TRUNC(DATE(TIMESTAMP_SECONDS(CAST(transaction_date_sk / 1000 AS INT64))), MONTH)
CLUSTER BY
  applicant_sk, card_product_sk
OPTIONS (
  partition_expiration_days = 3650, -- ~10 years
  description = "Fact table storing details of the first transaction made by a new cardholder.",
  labels = [('layer', 'gold'), ('domain', 'transaction')]
);
```

---

#### **Error Data Table DDL script**

```sql
-- DDL for Go_Data_Validation_Error_Log
CREATE TABLE IF NOT EXISTS Gold.Go_Data_Validation_Error_Log (
    error_id STRING NOT NULL OPTIONS(description="A unique identifier for each error record."),
    pipeline_run_id STRING OPTIONS(description="The identifier of the pipeline run during which the error occurred."),
    error_timestamp TIMESTAMP NOT NULL OPTIONS(description="The timestamp when the error was logged."),
    source_table STRING OPTIONS(description="The source Silver table from which the problematic record originated."),
    record_identifier STRING OPTIONS(description="A unique reference to the source record (e.g., a natural key or hash)."),
    column_name STRING OPTIONS(description="The name of the column where the error was detected."),
    failed_rule STRING OPTIONS(description="The specific data quality or business rule that the record failed."),
    error_description STRING OPTIONS(description="A detailed description of the validation failure."),
    erroneous_value STRING OPTIONS(description="The actual data value that caused the error.")
)
PARTITION BY
  DATE(error_timestamp)
CLUSTER BY
  pipeline_run_id, failed_rule, source_table
OPTIONS (
  partition_expiration_days = 365, -- 1 year
  description = "Captures detailed information about records that fail validation during Silver-to-Gold transformation.",
  labels = [('layer', 'gold'), ('type', 'governance')]
);
```

---

#### **Audit table DDL script**

```sql
-- DDL for Go_Process_Audit_Log
CREATE TABLE IF NOT EXISTS Gold.Go_Process_Audit_Log (
    pipeline_run_id STRING NOT NULL OPTIONS(description="A unique identifier for each execution of a pipeline."),
    pipeline_name STRING OPTIONS(description="The name of the pipeline that was executed (e.g., 'silver_to_gold_facts')."),
    start_timestamp TIMESTAMP NOT NULL OPTIONS(description="The timestamp when the pipeline run began."),
    end_timestamp TIMESTAMP OPTIONS(description="The timestamp when the pipeline run finished."),
    status STRING OPTIONS(description="The final status of the run ('Success', 'Failed')."),
    source_tables STRING OPTIONS(description="A list of source tables read during the pipeline run."),
    target_table STRING OPTIONS(description="The destination table in the Gold layer."),
    rows_read INT64 OPTIONS(description="The total number of rows read from the source(s)."),
    rows_written INT64 OPTIONS(description="The total number of rows written to the target table."),
    run_by_user STRING OPTIONS(description="The service account or user that executed the pipeline.")
)
PARTITION BY
  DATE(start_timestamp)
CLUSTER BY
  pipeline_name, status, target_table
OPTIONS (
  partition_expiration_days = 730, -- 2 years
  description = "Tracks metadata for each data processing pipeline run that loads data into the Gold layer.",
  labels = [('layer', 'gold'), ('type', 'governance')]
);
```

---

#### **Aggregated Tables DDL script**

```sql
-- DDL for Go_Agg_Campaign_Performance
CREATE TABLE IF NOT EXISTS Gold.Go_Agg_Campaign_Performance (
    report_date_sk INT64 NOT NULL OPTIONS(description="Foreign key to Go_Dim_Date for the reporting date."),
    campaign_sk INT64 NOT NULL OPTIONS(description="Foreign key to the Go_Dim_Campaign table."),
    marketing_cost FLOAT64 OPTIONS(description="The total cost associated with the campaign."),
    total_applications INT64 OPTIONS(description="The total number of applications generated."),
    approved_applications INT64 OPTIONS(description="The number of applications that were approved."),
    activated_cards INT64 OPTIONS(description="The number of cards that were activated."),
    approval_rate FLOAT64 OPTIONS(description="The calculated approval rate (Approved / Total)."),
    activation_rate FLOAT64 OPTIONS(description="The calculated activation rate (Activated / Approved)."),
    cost_per_acquisition FLOAT64 OPTIONS(description="The calculated cost to acquire one activated customer."),
    load_date TIMESTAMP NOT NULL OPTIONS(description="The date the aggregated record was created or updated.")
)
PARTITION BY
  DATE_TRUNC(DATE(TIMESTAMP_SECONDS(CAST(report_date_sk / 1000 AS INT64))), YEAR)
CLUSTER BY
  campaign_sk
OPTIONS (
  description = "Aggregated table with pre-calculated KPIs for campaign performance reporting.",
  labels = [('layer', 'gold'), ('type', 'aggregation')]
);
```

---

#### **Update DDL script**

```sql
-- Example: Add a new metric 'credit_limit_allocated' to the Go_Fact_Application table.
ALTER TABLE Gold.Go_Fact_Application
ADD COLUMN credit_limit_allocated NUMERIC OPTIONS(description="The total credit limit allocated for approved applications.");
```

---

### **2. Data Retention Policies**

*   **Retention periods for the Gold layer:**
    *   **Fact and Aggregated Tables** (`Go_Fact_Application`, `Go_Fact_Transaction`, `Go_Agg_Campaign_Performance`): **10 years**. These tables are critical for long-term strategic analysis, trend reporting, and machine learning model training. A 10-year retention period (`partition_expiration_days = 3650`) provides a deep historical view.
    *   **Dimension Tables** (`Go_Dim_Applicant`, `Go_Dim_Card_Product`, etc.): **Active for life of facts**. Dimensions should be retained as long as there are corresponding records in the fact tables that reference them. They typically do not have an automatic expiration policy.
    *   **Governance Tables** (`Go_Process_Audit_Log`, `Go_Data_Validation_Error_Log`): **1-2 years**. Audit logs are kept for 2 years (`730 days`), and error logs for 1 year (`365 days`), for operational monitoring and data quality analysis.

*   **Archiving Strategies:**
    *   **Procedure:** Before a partition expires (primarily for fact and governance tables), an automated pipeline (e.g., Cloud Composer DAG) will execute a BigQuery export job.
    *   **Format:** Data will be exported to **Parquet** format.
    *   **Destination:** The exported files will be stored in a **Google Cloud Storage (GCS) Archive Storage** bucket for cost-effective long-term retention.
    *   **Access:** If needed, archived data can be queried from GCS using BigQuery federated queries by creating an external table pointing to the archive location.

---

### **3. Conceptual Data Model Diagram**

| From Table (Fact)            | To Table (Dimension)         | Relationship Key (Surrogate Key) |
| :--------------------------- | :--------------------------- | :------------------------------- |
| `Go_Fact_Application`        | `Go_Dim_Applicant`           | `applicant_sk`                   |
| `Go_Fact_Application`        | `Go_Dim_Card_Product`        | `card_product_sk`                |
| `Go_Fact_Application`        | `Go_Dim_Acquisition_Channel` | `acquisition_channel_sk`         |
| `Go_Fact_Application`        | `Go_Dim_Campaign`            | `campaign_sk`                    |
| `Go_Fact_Application`        | `Go_Dim_Credit_Risk`         | `credit_risk_sk`                 |
| `Go_Fact_Application`        | `Go_Dim_Fraud_Check`         | `fraud_check_sk`                 |
| `Go_Fact_Application`        | `Go_Dim_Date`                | `application_date_sk`            |
| `Go_Fact_Transaction`        | `Go_Dim_Applicant`           | `applicant_sk`                   |
| `Go_Fact_Transaction`        | `Go_Dim_Card_Product`        | `card_product_sk`                |
| `Go_Fact_Transaction`        | `Go_Dim_Date`                | `transaction_date_sk`            |
| `Go_Agg_Campaign_Performance`| `Go_Dim_Campaign`            | `campaign_sk`                    |
| `Go_Agg_Campaign_Performance`| `Go_Dim_Date`                | `report_date_sk`                 |

---

### **4. ER Diagram Visualization Graph**

```mermaid
graph TD
    subgraph Dimensions
        D1[Go_Dim_Applicant]
        D2[Go_Dim_Card_Product]
        D3[Go_Dim_Acquisition_Channel]
        D4[Go_Dim_Campaign]
        D5[Go_Dim_Credit_Risk]
        D6[Go_Dim_Fraud_Check]
        D7[Go_Dim_Date]
    end

    subgraph Facts
        F1[Go_Fact_Application]
        F2[Go_Fact_Transaction]
    end

    subgraph Aggregations
        A1[Go_Agg_Campaign_Performance]
    end

    subgraph Governance
        G1[Go_Process_Audit_Log]
        G2[Go_Data_Validation_Error_Log]
    end

    F1 -- applicant_sk --> D1
    F1 -- card_product_sk --> D2
    F1 -- acquisition_channel_sk --> D3
    F1 -- campaign_sk --> D4
    F1 -- credit_risk_sk --> D5
    F1 -- fraud_check_sk --> D6
    F1 -- application_date_sk --> D7

    F2 -- applicant_sk --> D1
    F2 -- card_product_sk --> D2
    F2 -- transaction_date_sk --> D7

    A1 -- campaign_sk --> D4
    A1 -- report_date_sk --> D7
```

---
*   **apiCost:** 0.0025734